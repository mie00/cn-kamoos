<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini API Frontend - Advanced</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        label { display: block; margin-top: 15px; margin-bottom: 5px; font-weight: bold; }
        input[type="file"], input[type="password"], input[type="text"], textarea {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px;
            border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;
        }
        textarea { min-height: 100px; resize: vertical; }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; font-size: 16px; margin-right: 10px;
        }
        button#stopButton { background-color: #dc3545; }
        button#stopButton:hover { background-color: #c82333; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #outputContainer, #usageMetadataContainer {
            margin-top: 20px; border: 1px solid #ddd; padding: 15px; background-color: #f9f9f9;
            min-height: 50px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word;
            line-height: 1.6; /* Improved readability for multi-line metadata */
        }
        #outputContainer {min-height: 150px;}
        .file-info { font-style: italic; font-size: 0.9em; color: #555; margin-bottom:10px; }
        .error { color: red; font-weight: bold; }
        .spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 20px; height: 20px; animation: spin 1s linear infinite;
            display: none; margin-left: 10px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <!-- Mammoth.js for DOCX to text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- docx library for creating DOCX files - Using jsDelivr -->
    <script src="https://cdn.jsdelivr.net/npm/docx@8.2.2/build/index.umd.min.js"></script>

</head>
<body>
    <div class="container">
        <h1>Gemini API Frontend - Advanced</h1>

        <label for="apiKey">Gemini API Key:</label>
        <input type="password" id="apiKey" placeholder="Enter your API Key">

        <label for="systemPromptTextarea">System Prompt:</label>
        <textarea id="systemPromptTextarea" placeholder="Enter system prompt here..."></textarea>

        <label for="userFile">User Prompt File (user.docx):</label>
        <input type="file" id="userFile" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
        <div id="userFileInfo" class="file-info"></div>

        <label for="modelName">Model Name:</label>
        <input type="text" id="modelName" value="gemini-2.5-pro-preview-05-06"> <!-- Default model -->

        <button id="generateButton">Generate</button>
        <button id="stopButton" style="display:none;">Stop Generation</button>
        <div id="spinner" class="spinner"></div>

        <h2>Output:</h2>
        <div id="outputContainer"></div>

        <h2>Usage Metadata:</h2>
        <div id="usageMetadataContainer">
            Prompt Tokens: N/A<br>
            Candidates Tokens: N/A<br>
            Total Tokens: N/A
        </div>

        <button id="saveButton" style="margin-top: 15px;" disabled>Save Output as DOCX</button>
    </div>

    <script>
        const apiKeyInput = document.getElementById('apiKey');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');
        const userFileInput = document.getElementById('userFile');
        const modelNameInput = document.getElementById('modelName');
        const generateButton = document.getElementById('generateButton');
        const stopButton = document.getElementById('stopButton');
        const outputContainer = document.getElementById('outputContainer');
        const usageMetadataContainer = document.getElementById('usageMetadataContainer');
        const saveButton = document.getElementById('saveButton');
        const userFileInfo = document.getElementById('userFileInfo');
        const spinner = document.getElementById('spinner');

        let userPromptText = "";
        let abortController = null;
        let displayedPromptTokenCount = null; // Store prompt token count once received

        function loadApiKey() {
            const savedKey = localStorage.getItem('geminiApiKey');
            if (savedKey) apiKeyInput.value = savedKey;
        }
        function saveApiKey() {
            if (apiKeyInput.value) localStorage.setItem('geminiApiKey', apiKeyInput.value);
        }
        function loadSystemPrompt() {
            const savedPrompt = localStorage.getItem('geminiSystemPrompt');
            if (savedPrompt) systemPromptTextarea.value = savedPrompt;
        }
        function saveSystemPrompt() {
            localStorage.setItem('geminiSystemPrompt', systemPromptTextarea.value);
        }

        apiKeyInput.addEventListener('change', saveApiKey);
        systemPromptTextarea.addEventListener('change', saveSystemPrompt);
        document.addEventListener('DOMContentLoaded', () => {
            loadApiKey();
            loadSystemPrompt();
            if (typeof docx === 'undefined') {
                console.error("DOCX library (docx) not loaded!");
            } else {
                console.log("DOCX library loaded successfully.");
            }
             if (typeof mammoth === 'undefined') {
                console.error("DOCX reading library (mammoth) not loaded!");
            }
        });

        userFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            userFileInfo.classList.remove('error');
            if (file) {
                userFileInfo.textContent = `Loading: ${file.name}...`;
                try {
                    if (typeof mammoth === 'undefined') {
                        throw new Error("Mammoth.js library not loaded. Cannot read DOCX.");
                    }
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                    userPromptText = result.value;
                    userFileInfo.textContent = `Loaded: ${file.name} (${file.size} bytes). Preview: ${userPromptText.substring(0,100)}...`;
                } catch (error) {
                    console.error("Error processing DOCX file:", error);
                    userPromptText = "";
                    userFileInfo.textContent = `Error reading DOCX: ${error.message || 'Unknown error'}`;
                    userFileInfo.classList.add('error');
                }
            } else {
                userPromptText = "";
                userFileInfo.textContent = "";
            }
        });

        stopButton.addEventListener('click', () => {
            if (abortController) {
                abortController.abort();
                console.log("Generation aborted by user.");
            }
        });

        function resetUIForNewGeneration() {
            outputContainer.textContent = "";
            outputContainer.classList.remove('error');
            usageMetadataContainer.innerHTML = "Prompt Tokens: N/A<br>Candidates Tokens: N/A<br>Total Tokens: N/A";
            usageMetadataContainer.classList.remove('error');
            displayedPromptTokenCount = null; // Reset for the new generation
            saveButton.disabled = true;
            generateButton.disabled = true;
            stopButton.style.display = 'inline-block';
            spinner.style.display = 'inline-block';
        }

        function finalizeUIAfterGeneration(wasError = false) {
            generateButton.disabled = false;
            stopButton.style.display = 'none';
            spinner.style.display = 'none';
            if (!wasError && outputContainer.textContent.trim()) {
                saveButton.disabled = false;
            }
        }

        generateButton.addEventListener('click', async () => {
            const apiKey = apiKeyInput.value.trim();
            const systemPrompt = systemPromptTextarea.value.trim();
            const modelName = modelNameInput.value.trim() || "gemini-2.5-pro-preview-05-06";

            if (!apiKey) { alert("Please enter your API Key."); return; }
            if (!systemPrompt) { alert("Please enter a system prompt."); return; }
            if (!userPromptText) { alert("Please upload a user prompt DOCX file."); return; }

            resetUIForNewGeneration();
            saveApiKey();
            saveSystemPrompt();

            abortController = new AbortController();
            const signal = abortController.signal;

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:streamGenerateContent?key=${apiKey}&alt=sse`;

            const requestBody = {
                "contents": [{ "role": "user", "parts": [{ "text": userPromptText }] }],
                "systemInstruction": { "parts": [{ "text": systemPrompt }] },
                "generationConfig": { "responseMimeType": "text/plain" }
            };

            let reader;
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: signal
                });

                if (!response.ok) {
                    let errorData;
                    try { errorData = await response.json(); }
                    catch (e) { throw new Error(`HTTP error ${response.status} - ${response.statusText}`); }
                    const errorMessage = errorData?.error?.message || `API Error: ${response.status}`;
                    throw new Error(errorMessage);
                }

                reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    if (signal.aborted) {
                        console.log("Stream reading aborted.");
                        outputContainer.textContent += "\n\n--- Generation stopped by user ---";
                        break;
                    }

                    const { value, done } = await reader.read();

                    if (done) {
                        if (buffer.trim()) processSseLine(buffer.trim());
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    let newlineIndex;
                    while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
                        const line = buffer.substring(0, newlineIndex).trim();
                        buffer = buffer.substring(newlineIndex + 1);
                        processSseLine(line);
                    }
                }
                // finalizeUIAfterGeneration is called in the finally block or on normal completion inside try
                if (!signal.aborted) { // Only call if not aborted, as abort path handles its own finalization
                    finalizeUIAfterGeneration();
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Fetch aborted.");
                    // Message already added to outputContainer during abort signal check
                } else {
                    console.error("Error during generation:", error);
                    outputContainer.textContent = `Error: ${error.message}`;
                    outputContainer.classList.add('error');
                }
                finalizeUIAfterGeneration(true);
            } finally {
                if (reader) {
                    try {
                        if (!reader.closed) { // Check if reader is not already closed
                           await reader.cancel();
                           console.log("Stream reader cancelled.");
                        }
                    } catch (cancelError) {
                        console.warn("Error cancelling stream reader:", cancelError);
                    }
                }
                abortController = null;
                // Ensure UI finalization if it wasn't handled due to an unexpected exit
                if (generateButton.disabled && stopButton.style.display !== 'none') {
                     finalizeUIAfterGeneration(true); // Assume error or incomplete state
                }
            }
        });

        function processSseLine(line) {
            if (line.startsWith("data:")) {
                const jsonString = line.substring(5).trim();
                if (jsonString && jsonString.toLowerCase() !== "[done]") {
                    try {
                        const chunkData = JSON.parse(jsonString);

                        if (chunkData.candidates?.[0]?.content?.parts?.[0]?.text) {
                            outputContainer.textContent += chunkData.candidates[0].content.parts[0].text;
                        }

                        if (chunkData.usageMetadata) {
                            const { promptTokenCount, candidatesTokenCount, totalTokenCount } = chunkData.usageMetadata;

                            // Capture promptTokenCount once
                            if (displayedPromptTokenCount === null && promptTokenCount !== undefined) {
                                displayedPromptTokenCount = promptTokenCount;
                            }

                            const promptDisplay = displayedPromptTokenCount !== null ? displayedPromptTokenCount : (promptTokenCount !== undefined ? promptTokenCount : "N/A");
                            const candidatesDisplay = candidatesTokenCount !== undefined ? candidatesTokenCount : "N/A";
                            const totalDisplay = totalTokenCount !== undefined ? totalTokenCount : "N/A";

                            usageMetadataContainer.innerHTML =
                                `Prompt Tokens: ${promptDisplay}<br>` +
                                `Candidates Tokens: ${candidatesDisplay}<br>` +
                                `Total Tokens: ${totalDisplay}`;
                        }

                        if (chunkData.promptFeedback) { /* console.log("Prompt Feedback:", chunkData.promptFeedback); */ }
                        else if (chunkData.error) {
                            const errorMsg = chunkData.error.message || "Unknown error in stream chunk";
                            outputContainer.textContent += `\nERROR from stream: ${errorMsg}\n`;
                            outputContainer.classList.add('error');
                            console.error("Stream error chunk:", chunkData.error);
                        }
                    } catch (e) {
                        console.error("Failed to parse JSON from data line:", jsonString, e);
                        outputContainer.textContent += `\n[Error parsing stream data: ${jsonString.substring(0,50)}...]\n`;
                        outputContainer.classList.add('error');
                    }
                } else if (jsonString.toLowerCase() === "[done]") {
                    console.log("SSE stream finished with [DONE] message.");
                }
            } else if (line.startsWith("event:") || line.startsWith("id:") || line.startsWith("retry:") || line === "") {
                // console.log("SSE control line:", line);
            } else if (line) {
                console.warn("Received unexpected non-SSE line in stream:", line);
            }
        }

        saveButton.addEventListener('click', () => {
            const textToSave = outputContainer.textContent;
            if (!textToSave.trim()) {
                alert("Nothing to save.");
                return;
            }
            if (typeof docx === 'undefined' || !docx.Document) {
                alert("DOCX library is not loaded correctly. Cannot save as .docx.");
                console.error("Attempted to save DOCX, but 'docx' object or 'docx.Document' is undefined.");
                return;
            }
            const { Document, Packer, Paragraph, TextRun, AlignmentType, FootnoteReferenceRun, Footnote } = docx;
            const paragraphs = [];
            let currentIndex = 0;
            let footnoteNumber = 1;
            const docFootnotes = {};

            // Helper function to process a text segment for notes and convert to runs
            function processSegmentForNotes(segmentText, currentFootnoteNumber, footnotesContainer) {
                const runs = [];
                let textPointer = 0;
                let noteNum = currentFootnoteNumber;

                while (textPointer < segmentText.length) {
                    const noteOpenIndex = segmentText.indexOf("<note>", textPointer);
                    if (noteOpenIndex === -1) { // No more notes in this segment
                        if (textPointer < segmentText.length) {
                            runs.push(new TextRun(segmentText.substring(textPointer)));
                        }
                        break;
                    }

                    // Add text before the note
                    if (noteOpenIndex > textPointer) {
                        runs.push(new TextRun(segmentText.substring(textPointer, noteOpenIndex)));
                    }

                    // Process the note
                    const noteCloseIndex = segmentText.indexOf("</note>", noteOpenIndex + "<note>".length);
                    if (noteCloseIndex === -1) { // Malformed note tag
                        console.warn(`Malformed <note> tag at position ${noteOpenIndex} in segment "${segmentText.substring(0,50)}...". Treating rest of segment as plain text from <note> onwards.`);
                        runs.push(new TextRun(segmentText.substring(noteOpenIndex))); // Include the <note> tag itself as text
                        break;
                    }

                    const noteContent = segmentText.substring(noteOpenIndex + "<note>".length, noteCloseIndex);
                    
                    footnotesContainer[noteNum] = new Footnote({
                        children: [new Paragraph({
                            children: [new TextRun(noteContent)],
                            alignment: AlignmentType.RIGHT,
                            bidirectional: true,
                        })]
                    });
                    runs.push(new FootnoteReferenceRun(noteNum));
                    noteNum++;
                    
                    textPointer = noteCloseIndex + "</note>".length;
                }
                return { runs, updatedFootnoteNumber: noteNum };
            }

            while (currentIndex < textToSave.length) {
                const nextOriginalOpen = textToSave.indexOf("<original>", currentIndex);
                const nextGeneratedOpen = textToSave.indexOf("<generated>", currentIndex);

                let firstTagOpenIndex = -1;
                let tagType = null; // 'original' or 'generated'
                let openTagString = "";
                let closeTagString = "";

                if (nextOriginalOpen !== -1 && (nextGeneratedOpen === -1 || nextOriginalOpen < nextGeneratedOpen)) {
                    firstTagOpenIndex = nextOriginalOpen;
                    tagType = 'original';
                    openTagString = "<original>";
                    closeTagString = "</original>";
                } else if (nextGeneratedOpen !== -1) {
                    firstTagOpenIndex = nextGeneratedOpen;
                    tagType = 'generated';
                    openTagString = "<generated>";
                    closeTagString = "</generated>";
                }

                if (firstTagOpenIndex === -1) { // No more <original> or <generated> tags
                    if (currentIndex < textToSave.length) {
                        const remainingText = textToSave.substring(currentIndex);
                        remainingText.split('\n').forEach(line => {
                            const { runs, updatedFootnoteNumber } = processSegmentForNotes(line, footnoteNumber, docFootnotes);
                            footnoteNumber = updatedFootnoteNumber;
                            if (runs.length > 0 || line.trim() === "") { // Create paragraph if runs exist or it's an intentionally empty line
                                paragraphs.push(new Paragraph({ children: runs.length > 0 ? runs : [new TextRun("")] }));
                            }
                        });
                    }
                    break; 
                }

                // Process text before the found <original> or <generated> tag
                if (firstTagOpenIndex > currentIndex) {
                    const plainTextSegment = textToSave.substring(currentIndex, firstTagOpenIndex);
                    plainTextSegment.split('\n').forEach(line => {
                        const { runs, updatedFootnoteNumber } = processSegmentForNotes(line, footnoteNumber, docFootnotes);
                        footnoteNumber = updatedFootnoteNumber;
                        if (runs.length > 0 || line.trim() === "") {
                             paragraphs.push(new Paragraph({ children: runs.length > 0 ? runs : [new TextRun("")] }));
                        }
                    });
                }

                const tagContentStartIndex = firstTagOpenIndex + openTagString.length;
                const tagContentEndIndex = textToSave.indexOf(closeTagString, tagContentStartIndex);

                if (tagContentEndIndex === -1) {
                    console.warn(`Malformed tag: ${openTagString} found at ${firstTagOpenIndex} without a closing ${closeTagString}. Treating subsequent content as plain.`);
                    const remainingText = textToSave.substring(currentIndex); // Process from current index
                    remainingText.split('\n').forEach(line => {
                        const { runs, updatedFootnoteNumber } = processSegmentForNotes(line, footnoteNumber, docFootnotes);
                        footnoteNumber = updatedFootnoteNumber;
                        if (runs.length > 0 || line.trim() === "") {
                            paragraphs.push(new Paragraph({ children: runs.length > 0 ? runs : [new TextRun("")] }));
                        }
                    });
                    break; 
                }

                // Process tagged content (<original> or <generated>)
                const taggedContent = textToSave.substring(tagContentStartIndex, tagContentEndIndex);
                const alignment = (tagType === 'original') ? AlignmentType.LEFT : AlignmentType.RIGHT;
                taggedContent.split('\n').forEach(line => {
                    const { runs, updatedFootnoteNumber } = processSegmentForNotes(line, footnoteNumber, docFootnotes);
                    footnoteNumber = updatedFootnoteNumber;
                    if (runs.length > 0 || line.trim() === "") {
                        paragraphs.push(new Paragraph({
                            children: runs.length > 0 ? runs : [new TextRun("")],
                            alignment: alignment
                        }));
                    }
                });
                currentIndex = tagContentEndIndex + closeTagString.length;
            }

            const doc = new Document({
                sections: [{
                    properties: {},
                    children: paragraphs
                }],
                footnotes: docFootnotes
            });

            Packer.toBlob(doc).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'gemini_output.docx';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }).catch(err => {
                console.error("Error packing DOCX:", err);
                alert("Error creating DOCX file. Check console.");
            });
        });
    </script>
</body>
</html>
